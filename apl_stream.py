# -*- coding: utf-8 -*-
"""APL_Stream.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vFuUe8alYiCZWe72G4vMA-tEIhvn9DaP
"""

import streamlit as st
import pandas as pd
from apl_call import preprocess_data, load_model, make_prediction

def main():
    st.title("APL Logistics Prediction Interface")

    # Load model
    model_file = "APL_Logisitcs_Model.joblib"  # Assuming the model file is in the same directory
    model = load_model(model_file)

    # Read CSV file
    data = pd.read_csv("Check_1.csv")
    # Preprocess the data and make predictions
    predictions_data = make_prediction(model, preprocess_data(data))
    col_or = list(predictions_data.columns)  # Convert Index to list to modify it
    if "Predictions" in col_or:
        col_or.remove("Predictions")

    # Display predictions
    st.write("Predictions Data:")
    st.write(predictions_data)

    # Sidebar for adjusting columns and forecasting
    st.sidebar.title("Adjust Columns & Forecasting")

    # Allow user to select columns to adjust for prediction
    selected_columns = st.sidebar.multiselect("Select columns to adjust for prediction", predictions_data.columns)
    if selected_columns:
        # Allow user to select row index for adjustment
        selected_row_index = st.sidebar.number_input('Select Row Index', min_value=0, max_value=len(predictions_data)-1, step=1)
        if selected_row_index is not None:
            selected_row = predictions_data.iloc[selected_row_index]


            # Dictionary to store adjusted values
            adjusted_values = {}

            # Input values for selected columns
            for col in selected_columns:
                new_val = st.sidebar.text_input(f"Enter value for {col}", value=selected_row[col])
                adjusted_values[col] = new_val

            # Remove "Predictions" column if present in adjusted values
            if "Predictions" in adjusted_values:
                del adjusted_values["Predictions"]
            adjusted_prediction = None
            inflation_rate = st.sidebar.number_input('Enter inflation rate (%)', value=0.0)
            # Predict button
            if st.sidebar.button("Predict"):
                # Create a copy of selected_columns
                selected_columns_copy = selected_columns.copy()

                # Remove columns from selected_columns_copy that are in adjusted_values
                selected_columns_copy = [col for col in selected_columns_copy if col not in adjusted_values]

                # Concatenate adjusted values with selected columns from data
                row_to_predict = pd.concat([pd.Series(adjusted_values), data.iloc[selected_row_index][selected_columns_copy]], axis=0)

                # Ensure all necessary columns are included
                missing_columns = set(predictions_data.columns) - set(row_to_predict.index)
                for col in missing_columns:
                    if col != "Predictions":  # Exclude "Predictions" column
                        row_to_predict[col] = predictions_data.loc[selected_row_index, col]
                
		

		# Reorder columns of row_to_predict to match original columns in data
                row_to_predict = row_to_predict[col_or]

                # Make prediction using row_to_predict
                adjusted_prediction = make_prediction(model, row_to_predict.to_frame().T)
                st.write("Adjusted Prediction:")
                st.write(adjusted_prediction)      

                forecasting_data = generate_forecasting(adjusted_prediction, inflation_rate)
                st.write("Forecasting Data:")
                st.write(forecasting_data)

def generate_forecasting(adjusted_prediction, inflation_rate):
    # Extract the values from the "Predictions" column
    prediction_values = adjusted_prediction["Predictions"].values

    # Ensure prediction_values is not empty
    if len(prediction_values) == 0:
        raise ValueError("Adjusted prediction values are empty.")

    # Ensure inflation_rate is a numeric value
    if not isinstance(inflation_rate, (int, float)):
        raise ValueError("Inflation rate must be a numeric value.")

    # Generate forecasting for the next 12 months based on the initial prediction and inflation rate
    forecasting_data = []
    for i in range(1, 13):
        forecast = prediction_values[0] * (1 + inflation_rate / 100) ** i
        forecasting_data.append({"Month": i, "Forecast": forecast})
    forecasting_df = pd.DataFrame(forecasting_data)
    return forecasting_df

if __name__ == "__main__":
    main()